
1、I2C的定义，特点 通信协议
  通信协议：
     1）三个信号 start stop ack
     2) 发送/接收一个字节
		 3）发送/接收多个字节
  注意at24c02中的跨页回绕问题
2、字符设备驱动开发
   按键第一版： 
       cdev dev_t file_operations file inode
       kmalloc request_irq  ioremap
       gpio timer 顶半部底半部 并发与竞态
       等待队列 系统调用 自动创建设备文件
   按键第二版
        input子系统：把输入设备驱动程序中
          的公用代码都写好了，可以重复使用
        相对固定的编程步骤 + 硬件操作
   按键第三版
        总线设备驱动模型
           platform: 软硬件分离的思想，使驱动程序具有更好地可移植性
                     device体现硬件
                     driver体现软件
   ds18b20:一线式设备
   at24c02: I2C接口
   ADC: 

------------------------------------------
智能家居
    重点内容：
       1）开发环境的搭建
       2）QT程序向开发板的移植
       3）项目的发布
       4）体会嵌入式项目的开发流程
       5）嵌入式软件的开发调试
智能车项目
    重点内容：
       1）音频 mp3
       2) 视频 
       3）wifi
       4) 动力模块
          直流电机
          舵机
--------------------------------------------
软件开发流程
   1）立项
   2）需求分析，项目经理 核心软件工程师
      项目中要实现的功能
          项目需求文档 （客户签字）
   3）软硬件选型
      硬件选型： CPU 外围关键设备
      软件的选型：该硬件上是否需要操作系统
                  需要什么样的操作系统  
 
   4）概要设计
      框架功能的设计，是否采用多进程多线程
      划分成几个进程几个线程
      每个进程负责完成什么样的工作
      进程间通信的方式，进程间通信的数据格式
      同步问题
      《概要设计文档》
   5）详细设计
      具体的每个函数的流程图
   6）编码
   7）测试
   8）项目的发布
   
   CMMI: CMMI3
         CMMI5
----------------------------------------------
1、智能家居的功能需求分析
  无线通信：zigbee 蓝牙 wifi nordic
            zigbee的协议非常复杂
  ehome_user_alpha_v5.7z
  		1）cd /home/tarena 
  		  mkdir project
      2) cd project
      3) cp /mnt/hgfs/project/ehome_user_alpha_v5.7z ./
      4) 安装7z软件
         sudo dpkg -i p7zip-full_9.20.1~dfsg.1-4_i386.deb
      5) 7z x ehome_user_alpha_v5.7z
      6）Kernel_2.6.35.7_CW210_for_Linux_v1.0.tar.gz
         tar xf
      7) 修改内核源码目录(可选择)
      8）编译内核
         cp docs/CW210_CONFIG kernel_header/.config
         cd kernel_header
         vi Makefile
            CROSS_COMPILE   ?= arm-linux-

         make
      9) make app_install
         make pc_install
         make image
         执行以上指令需要arm-linux-gcc 、qt相关的工具软件
         如果没有，需要安装
         make 出错 时注意是否和qt程序相关
         如果是 qmake -v 是否为4.8.1
         如果不是 qt-ubuntu.tar.gz
         
         cd /tmp
         cp /mnt/hgfs/project/qt/qt-ubuntu.tar.gz ./
         mkdir qttool
         tar xvf qt-ubuntu.tar.gz -C qttool/
         sudo dpkg -i *
      10） 烧写镜像到开发板
        tftp server  /tftpboot
           cd images
           cp * /tftpboot/
        注意：烧写的zImage,使用驱动课编译成功的   
           
           
      11)启动参数的设置
          setenv bootcmd 'nand read 50008000 300000 500000; nand read 50800000 1000000 800000; bootm 50008000'      
          setenv bootargs root=/dev/ram0 console=ttySAC0,115200 initrd=0x50800000,0x800000 mtdparts=s5pv210-nand:1m@0(bios),1m(params),1m(logo),5m(kernel),8m(data),8m(ramdisk)ro,-(home)
            
          saveenv
          
     启动成功
         ifconfig eth0 192.168.1.6  
     在PC机上执行
         ./ehmanager
         在PC机上能取获取温度和系统参数    
---------------------------------------------         

cp kernel.tar.gz ./
tar xf kernel.tar.gz
cp project/user/docs/CW210_CONFIG kernel/.config
vi Makefile
   CROSS_COMPILE=arm-linux-
make  
 
测试触摸屏是否可用
   hexdump /dev/event0/1/2

  实现功能总结：
     1）客厅灯控制 （无线通信使用zigbee）
        直接控制开发板的LED灯
        
     2) 报警开关 
     3) 获取开发板系统信息
        cpu工作频率
        剩余磁盘空间
        空闲内存
     4）A/D， 可调变阻器来模拟烟感报警 
        当烟雾浓度（电压值）达到一定值报警
     5）在线升级功能  
        u盘来升级
     6）QT 贪食蛇游戏
     7）远程登陆、远程控制
  概要设计 
      desgin.bmp
  详细设计
-------------------------------------------
1、搭建开发环境
  1.1编译内核，保证该内核中触摸屏驱动能正常使用
     hexdump /eventX
     点击触摸屏是否有输出
  1.2制作一个最小根文件系统
      a) make menuconfig
         动态库
         Busybox Settings  --->
         		Build Options  ---> 
         				  [*] Build shared libbusybox 
         软链接
         Busybox Settings  --->
         			Installation Options ("make install" behavior)  ---> 
         					 What kind of applet links to install (as soft-links)  --->
         					 			(X) as soft-links 
      b) 修改Makefile
         ARCH = arm
         CROSS_COMPILE = arm-linux-
      c) make && make install
      d) mkdir /home/tarena/project/rootfs
      e) cp _install/* /home/tarena/project/rootfs -av
      f) mkdir lib
         cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/ld-* ./ -av
         cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libm-2.10.1.so ./ -av
				 cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libm.so* ./ -av
				 cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libc-2.10.1.so ./ -av
         cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libc.so* ./ -av

      g) mkdir dev
         sudo mknod dev/console c 5 1
         sudo mknod dev/null c 1 3
         sudo chmod 666 dev/console
         sudo chmod 666 dev/null
      h)mkdir etc
         vi etc/inittab
           ::sysinit:/etc/init.d/rcS
  				 ::askfirst:-/bin/sh
           ::shutdown:/bin/umount -a -r
         mkdir etc/init.d
         vi etc/init.d/rcS
           #!/bin/sh
   					 mount -a
      			 mkdir /dev/pts
   					 mount -t devpts devpts /dev/pts
  					 echo /sbin/mdev >/proc/sys/kernel/hotplug
   					 mdev -s
             telnetd & 
 						sudo chmod 777 etc/init.d/rcS
 
            vi etc/fstab
 							proc    /proc   proc    defaults     0       0
							tmpfs   /tmp    tmpfs   defaults     0       0
							sysfs   /sys    sysfs   defaults     0       0
							tmpfs   /dev    tmpfs   defaults     0       0
  		i) mkdir tmp sys proc home var/run -p
  		j) vi etc/passwd(telnet)
     			root::0:0:root:/:/bin/ash
		setenv bootargs root=/dev/nfs init=/linuxrc console=ttySAC0 nfsroot=192.168.1.8:/home/tarena/hwj/project/rootfs ip=192.168.1.6:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on
		save

注意：mkdir /var/run -p 
     如果不进行以上文件夹的创建会导致emi_core异常退出。			
  1.3 通过tftp加载内核 
      nfs方式加载根文件系统
   
   setenv bootcmd tftp 20008000 zImage \;bootm 20008000 
   setenv bootargs noinitrd root=/dev/nfs console=ttySAC0 init=/linuxrc nfsroot=192.168.1.8:/home/tarena/project/rootfs ip=192.168.1.6:192.168.1.8:192.168.1.1:255.255.255.0::eth0 
2、QT的移植
  ldd ehmanager
     QtGui QtCore...
  现在如果要编译一个ARM ehmanager可执行
     QtGui QtCore... 
  参考QTE_ENV.pdf
  
  2.1需要ARM版本的QT库   
    2.1.1PC机上QT开发环境的建立
        安装包： qt-ubuntu.tar.gz
        cd /tmp
        cp /mnt/hgfs/project/tool/qt/qt-ubuntu.tar.gz ./
        tar xf qt-ubuntu.tar.gz
        sudo dpkg -i *.deb
   2.1.2 tslib
        它是触摸屏驱动和应用程序(QT gui)直接的适配层。
        tslib从驱动程序中读取原始的设备坐标，
        通过一系列的去抖、降噪、坐标变换等操作
        将原始设备坐标转换为屏幕坐标，
        将转换的屏幕坐标传递给应用程序(QT gui)
        源代码：tslib.tar.gz
        编译：
        1）cd /tmp
        2)cp /mnt/hgfs/project/tool/qt/tslib.tar.gz ./
        3) tar xf tslib.tar.gz
        4) cd tslib
        5)./autogen.sh --->用于生产configure
        6)echo "ac_cv_func_malloc_0_nonnull=yes"> tmp.cache
        7)mkdir /home/tarena/project/qtlib/build-tslib -p
          ./configure --host=arm-linux --cache-file=tmp.cache --enable-inputapi=no --prefix=/home/tarena/project/qtlib/build-tslib
           host:目标平台
           prefix：安装目录,该目录必须是已存在的目录
                  make install
          该操作执行完会自动生成了Makefile
        8)make 
        9)make install
   2.1.3 ARM版本的QT库
        /home/tarena/project/qtlib/build-qt
        源代码：qt-everywhere-opensource-src-4.8.4.tar.gz
        
        关于如何编译:QTE_ENV.pdf
        
        ./configure --help
          -prefix :安装目录
                  /home/tarena/project/qtlib/build-qtlib
          -I /home/tarena/project/qtlib/build-tslib/include
          -L /home/tarena/project/qtlib/build-tslib/lib
     
       ./configure会根据配置自动生成Makefile
       
       编译结果：build-qt.tar.gz
                 build-tslib.tar.gz
       cd project/qtlib
       cp build-qt.tar.gz
       tar xf build-qt.tar.gz 
   2.2 编译ARM版本的QT程序
     1）sudo vi /usr/share/qt4/mkspecs/qws/linux-arm-g++/qmake.conf
          
          QMAKE_CC                = arm-linux-gcc -lts
				  QMAKE_CXX               = arm-linux-g++ -lts
          QMAKE_LINK              = arm-linux-g++ -lts
          QMAKE_LINK_SHLIB        = arm-linux-g++ -lts
          QMAKE_INCDIR_QT = /home/tarena/project/qtlib/build-qt/include
          QMAKE_LIBDIR_QT = /home/tarena/project/qtlib/build-qt/lib  /home/tarena/project/qtlib/build-tslib/lib
          load(qt_config)
     2)进入qt例子程序源码目录
       
        qt-everywhere-opensource-src-4.8.4/examples/dialogs/standarddialogs
     3）生成工程文件
        qmake -project    
     4）编译生成一个能在ARM上运行的QT程序
       qmake -spec /usr/share/qt4/mkspecs/qws/linux-arm-g++/ standarddialogs.pro
       根据指定的qmake.conf 和工程文件自动生成合适的Makefile 
       
       vi Makefile
          LIBS = ..... /home/tarena/project/qtlib/build-qt/lib  
       如果向编译PC板QT可执行程序
       qmake -project
       qmake
       make 
注意：根文件保持不变
     应用相关的内容都放入home
     mdir rootfs/home/bin:和应用相关的可执行程序 
     mdir rootfs/home/etc:和应用相关的配置文件
     mdir rootfs/home/lib:和应用相关的库文件
   2.3移植编译好的ARM版本的QT程序
     1）ARM 板QT库   
       cp qtlib/build-qt/lib/* rootfs/home/lib/ -av
     2）ARM 版tslib
       a)cp qtlib/build-tslib/lib/* rootfs/home/lib/ -av
       b)拷贝tslib的配置文件
       c)cp qtlib/build-tslib/etc/ts.conf rootfs/home/etc/
       d)修改该配置文件
         vi rootfs/home/etc/ts.conf
            删除第二行的 “# ”
     3）将编译好的QT程序拷贝到home/bin
        cp qt-everywhere-opensource-src-4.8.4/examples/dialogs/standarddialogs/standarddialogs rootfs/home/bin/
     4)声明相关的环境变量
       cp user/libs/etc/profile rootfs/home/etc/
          LD_LIBRARY_PATH
           TSLIB_TSDEVICE：指定了触摸屏设备文件
             确定该变量的方法 hexdump /dev/evnentX 
           TSLIB_CONFFILE：tslib的配置文件路径
           TSLIB_PLUGINDIR：插件库路径
           TSLIB_CALIBFILE:屏幕校准文件
           
            QWS_SIZE:屏幕的分辨率
            QT_QWS_FONTDIR：指定字库的位置
            QT_PLUGIN_PATH：QT插件库路径
    在开发板上执行以下操作
       5）使配置的环境变量生效
         source /home/etc/profile  
       6）在开发板上执行屏幕校准程序
          cp qtlib/build-tslib/bin/ts_calibrate rootfs/home/bin/
          /home/bin/ts_calibrate 需要libld库文件
         解决方法：
            cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libdl*.so*  rootfs/home/lib/ -av
       7）./yourapp -qws
         问题： libpthread.so.0: cannot open
         解决方法：
             cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libpthread*.so* rootfs/home/lib/ -av
             cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libstdc++.so* rootfs/home/lib/ -av
             cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/libgcc_s.so* rootfs/home/lib/ -av
             cp /home/tarena/workdir/toolchains/opt/S5PV210-crosstools/4.4.6/arm-concenwit-linux-gnueabi/lib/librt*.so* rootfs/home/lib/ -av
    QT:贪食蛇
       美女摇奖  
在QT中关于图片的显示
1）将图片以资源的形式静态编译到可执行程序中去
  缺点，该图片文件会被编译到可执行程序中去
          会导致该程序加载到内存中执行时，加载速度慢
  优点，当程序执行时，即便删除该资源文件也补会影响到
        程序中图片的显示
2）动态加载图片
  编译QT源码包时要指定：-qt-libjpeg
  部署时： export QT_PLUGIN_PATH=$QTDIR/plugins
           cp qtlib/build-qt/plugins/ rootfs/home/ -avr       
  ui->label_2->setPixmap(QString::fromUtf8("images/test.jpg"));
  mkdir rootfs/home/bin/images
  cp /mnt/hgfs/project/test.jpg rootfs/home/bin/images/
  
              
3、实现智能家居项目中的功能
  3.1温度获取
     3.1.1硬件的驱动程序
          project/driver/ds18b20/
          ds18b20的驱动程序
            1）硬件原理图
            2）ds18b20的芯片手册
            3）s5pv210的芯片手册
     3.1.2 应用程序
         注意：主控界面的大小要调整为800*480
          project/ehome
             
             command 对应的槽函数
                {
                	fd = open("ds18b20"...)
                	read(fd, &data,4)
                	
                	label->setText(QString("%1 'C").arg((float)data*0.0625 ));
                }
          进一步要求：
              能把open ioctl read封装成一个函数get_temp(...)
              放入共享库中
              {
                	int data = get_temp(....);
                	
                	label->setText(QString("%1 'C").arg((float)data*0.0625 ));
                }
          再进一步的要求 C/S模式
             command ---clicked---->
                 send("5",....)服务器sever(arm)
             		 recv(,&data...)
             		 lable->setText
             server
                {
                	get_temp(....)
                	send(client)
                }
将操作硬件的函数封装成库
1）cd project
   mkdir applib
   ...
   vi EHOME.pro
       INCLUDEPATH += ../../applib/
       LIBS += -L../../applib/ -lapp
   qmake -spec /usr/share/qt4/mkspecs/qws/linux-arm-g++/ EHOME.pro
   make
 
  3.2beep报警控制
     1)驱动程序
     2)应用程序

DM9000网卡的移植：DM9000AEP.pdf
  3.3 烟雾浓度报警
    注意：如果原有ADC驱动程序不可用，
          内核中是否已经有了该adc的驱动程序，
             cat /proc/interrupts
                119
          如果存在已有的ADC，会和自己编写的ADC有冲突
          IORESOURCE_MEM
          IORESOURCE_IRQ	
     裁剪内核自带的ADC驱动
         make menuconfig
              Device Drivers  ---> 
                  Character devices  ---> 
                     CW210 ADCS' test driver 
                System Type  --->  
                     [ ] S5PXXXX ADC driver              
     实时监控烟雾浓度是否达到了报警值，
     如果达到了报警值，进行报警（beep led 短信。。。）
     可调变阻器来模拟获取到的烟雾浓度值
     
     创建一个新的线程  -lpthread
         #include <pthread.h>
         pthread_create(...func)
         
         func()
         {
         		open(...)
         		while(1)
         		{
         		   read(fd, &data)
         		   if(data > MAX)
         		   {
         		      //报警
         		   }
         		   else
         		   {
         		   		//取消报警
         		   }
         		}
         }
   3.4 获取系统参数
      1)cpu 主频
         /proc/cpuinfo
         BogoMIPS        :
      2）内存的使用率
         /proc/meminfo
          MemFree:
      3）nand使用率:
          /dev/mtdblock6   /home
          statfs(dev, &stat);
          strstr
     参考代码：
            user/eh_server/plugins/reciever/machine_info_reciever.c    
	 3.5 使用U盘自动升级系统
	     3.5.1手工挂载U盘
	        ls /dev/sda
	        mkdir /mnt
	        mount -t vfat /dev/sda1 /mnt
	        操作/mnt
	        umount /mnt
	     3.5.2u盘的自动挂载和卸载
	         usb.rar
	         1）mdev.conf
	            mdev自动创建设备文件的应用程序
	            rootfs/etc/mdev.conf
	            vi mdev.conf
	               sd[a-z][0-9] 0:0 666 @/home/usb/usb_insert.sh /dev/$MDEV 
                 sd[a-z] 0:0 666 $/home/usb/usb_remove.sh 
                 第一句话：用于自动挂载U盘
                 第二句话：用于自动卸载U盘
                 格式： 设备文件 用户：组  访问权限
                        @,表示插入某个设备执行后续命令
                        $, 表示拔出某个设备执行的命令
	           cd rootfs
	              vi  etc/mdev.conf
	                  sd[a-z][0-9] 0:0 666 @/home/usb/usb_insert.sh /dev/$MDEV 
                    sd[a-z] 0:0 666 $/home/usb/usb_remove.sh 
                mkdir home/usb
                vi home/usb/usb_insert.sh
                   echo $1 > /dev/console
                   mount -t vfat -o utf8=1 $1 /mnt/usb
	              home/usb/usb_remove.sh
	                  echo $1 > /dev/console
										sync
										umount  /mnt/usb
								mkdir mnt/usb -p
				3.5.3 升级内核时要将u盘中zImage 写入mtdblock3
				     tftp 20008000 zImage
				     nand erase
				     nand write
				     以上方式对于普通用户不可行
				     
				     利用mtd开源软件实现对某个分析的擦除和写入：mtd-utils-mtd-utils.rar
				    参考：利用U盘实现软件的在线升级.txt
				    project1411/update 
	     
	 3.6 软硬件的版本信息
	     软件版本号
	     硬件版本号
	     厂家编号
	     at24c02



4、系统的部署
   tftp zImage
   nfs  rootfs
   insmod xxx.ko
   /home/bin/xxx -qws
  4.1 nandflash分区
      s3c_nand.c
          struct mtd_partition s3c_partition_info
      cat /proc/mtd
      flash spec.bmp文件修改分区表
      make
      cp arch/arm/boot/zImage /tftpboot
  4.2自启动的完成
     inittab:内核初始化完成后，启动用户空间1号进程时
             该进程会去读取inittab
     rcS: 当inittab文件被解析后会执行/etc/init.d/rcS
          需要自动的命令放入该文件中 
     profile: 通常export环境变量
            启动login,有用户登录会执行该文件
            /etc/profile,对所有用户都有效
            ~/.bahsrc,只对某个特定用户有效 
     4.2.1 vi rootfs/etc/init.d/rcS
           mount /dev/mtdblock6 /home/  
           exec  /home/etc/rcS
     4.2.2 vi rootfs/home/etc/rcS
            ifconfig eth0 192.168.1.6
						ifconfig lo up
						
						find /home/modules/ -name "*.ko" -exec insmod {} \;
						
						source /home/etc/profile
						
						/home/bin/EHOME -qws  -font unifont &
				给该文件增加可执行属性：chmod +x rootfs/home/etc/rcS
		4.2.3  vi rootfs/etc/profile
		           source /home/etc/profile
	4.3制作根文件系统
	   应该掌握的： ramdisk cramfs yaffs2
	   在动手完成ramdisk之前可以先验证前面的自启动是否有效
	     1）vi rootfs/etc/init.d/rcS
	        #mount /dev/mtdblock6 /home/ 
	     2）重启开发板，验证是否能自启动
	   如果没有问题恢复vi rootfs/etc/init.d/rcS
	                       mount /dev/mtdblock6 /home/
	  根文件系统的类型为ramdisk类型，需要内核的支持
	      make menuconfig
	          Device Drivers  --->  
	              [*] Block devices  --->
	                    <*>   RAM block device support                                                  │ │  
  					│ │         (16)    Default number of RAM disks                                             │ │  
  					│ │         (8192)  Default RAM disk size (kbytes)
	       make 
	       cp arch/arm/boot/zImage /tftpboot
	  a) cd project
	     mkdir app
	     mv rootfs/home/* app/
	  b)mkdir images
	    sudo dd if=/dev/zero of=images/ramdisk.img count=8 bs=1024k
	    sudo mkfs.ext2 images/ramdisk.img 
      mkdir /tmp/ram -p 
      sudo mount images/ramdisk.img /tmp/ram
      sudo cp rootfs/* /tmp/ram/ -av
      sudo umount /tmp/ram	   
	4.4制作应用文件系统
	    cd project
	    mkdir tools
      cp user/tools/mkyaffs2image tools/
      tools/mkyaffs2image app/ images/app.img
  4.5烧写开发板
     1)u-boot.bin
       tftp 50008000 u-boot.bin
	     nand erase 0x0 0x100000
	     nand write 50008000 0x0 0x100000
     2)zImage
       tftp 50008000 zImage
			 nand erase 0x300000 0x500000
			 nand write 50008000 0x300000 0x500000
	   3)ramdisk
	     cp images/ramdisk.img /tftpboot/
	     tftp 50008000 ramdisk.img
	     nand erase 0x1000000 0x800000
	     nand write 50008000 0x1000000 0x800000
	   4)应用文件系统
	     cp images/app.img /tftpboot/
	     tftp 50008000 app.img
	         permisson den....
	         chmod 777 app.img
	     nand erase 0x1800000
	     nand write.yaffs 50008000 0x1800000 $(filesize)
   4.6 配置启动参数
       setenv bootcmd 'nand read 50008000 300000 500000; nand read 50800000 1000000 800000; bootm 50008000'        
       setenv bootargs root=/dev/ram0 console=ttySAC0,115200 initrd=0x50800000,0x800000
       saveenv 
       
       网络加载：
       setenv bootargs noinitrd root=/dev/nfs console=ttySAC0 init=/linuxrc nfsroot=192.168.1.8:/home/tarena/project/rootfs ip=192.168.1.6:192.168.1.8:192.168.1.1:255.255.255.0::eth0:on
       setenv bootcmd tftp c0008000 zImage\;bootm c0008000
       saveenv
-----------------------------------------------------------
智能车
    u-boot的移植
    内核的移植
    根文件系统制作
    tftp 加载内核
    nfs加载根文件系统
1、视频模块
 1.1关于摄像头驱动
    uvc: usb video class , 支持一系列USB接口的摄像头
        内核自带了部分usb接口的摄像头驱动程序
        
        如何判断内核是否支持该摄像头：
           把摄像头插入开发板
             lsusb
                 046d:0825
             将芯片型号 http://www.ideasonboard.org/uvc/
        插拔摄像头来观察设备文件/dev/videoX的变化
        如果没有变化说明内核中UVC驱动没有被编译到内核
    配置内核支持该设备驱动
        make menuconfig
            Device Drivers  ---> 
               <*> Multimedia support  ---> 
                   [*]   Video capture adapters  --->  
                        [*]   V4L USB devices  ---> 
                             <*>   USB Video Class (UVC)  
    v4l2:(video for linux ver2),
        中间层，向上给应用程序提供了统一的编程接口
        向下规定了不同摄像头驱动程序要完成的视频驱动函数
   
   
   1.2关于摄像头的应用程序
      应用程序功能： 
        1）读取图像帧数据
          open("/dev/videoX"...)
          ioctl();设置属性
          mmap();映射缓存到用户空间
          ioctl( VIDIOC_STREAMON,)启动摄像头采集数据
          ...                
        2）将读取到的图像帧数据以http协议形式发送给客户端
       mjpg-streamer开源软件可以实现以上两个功能：mjpg-streamer-r63.tar.gz 
     1.2.1编译arm版本的mjpg-streamer
        cd tcar
        mkdir video
        cd video
        cp /mnt/hgfs/project/tool/mjpg-streamer-r63.tar.gz ./
        tar xxx.tar.gz
        find ./ -name "Makefile" -exec sed -i "s/CC = gcc/CC = arm-linux-gcc/g" {} \;
     1.2.2部署
        cd rootfs/home
        mkdir etc bin lib modules
        cd video/mjpg-streamer
        cp *.so  /home/tarena/tcar/rootfs/home/lib -av
        cp mjpg_streamer /home/tarena/tcar/rootfs/home/bin/
        cp www  /home/tarena/tcar/rootfs/home/bin/ -r
        cp start.sh  /home/tarena/tcar/rootfs/home/bin/
     1.2.3程序的执行
        ./mjpg_streamer -i "input_uvc.so -d /dev/video3 -f 30 Cr 480x270 -y" -o "output_http.so -w www"                                                   
     1.2.4 PC上验证
        开启浏览器：192.168.1.6:8080   
    2.mjpg-streamer源码分析
      采用了插件的组织形式，本质上是使用了共享库
          dlopen
          dlsym
          dlclose
      以上解决的问题是降低了模块之间的耦合性
    2.1 mjpg-streamer.c
       main()
       {
         /*守护进程*/
       	 daemon_mode();
       	 /*加载插件 input_uvc.so*/ 
       	 global.in.handle = dlopen(global.in.plugin, RTLD_LAZY);
       	 global.in.init = dlsym(global.in.handle, "input_init");
       	 global.in.stop = dlsym(global.in.handle, "input_stop");
       	 global.in.run = dlsym(global.in.handle, "input_run");
       	 global.in.cmd = dlsym(global.in.handle, "input_cmd");
         
         global.in.init(&global.in.param)
         
         /*加载输出插件 output_http.so*/
         global.out[i].handle = dlopen(global.out[i].plugin, RTLD_LAZY);
         global.out[i].init = dlsym(global.out[i].handle, "output_init");
         global.out[i].stop = dlsym(global.out[i].handle, "output_stop");
         global.out[i].run = dlsym(global.out[i].handle, "output_run");
         global.out[i].cmd = dlsym(global.out[i].handle, "output_cmd");
         global.out[i].init(&global.out[i].param)
         
         global.in.run();
         global.out[i].run(global.out[i].param.id);
       }  
    2.2  plugins/input_uvc/
       按照v4l2框架来读取摄像头数据并保存数据到公共缓冲区    
       input_init（）
       {
       		init_videoIn(videoIn, dev, width, height, fps, format, 1)
       		{
       		   init_v4l2 (vd)
       		   {
       		   		/*open /dev/videoX*/
       		   		open(vd->videodevice, O_RDWR)
       		   		/*获取摄像头性能参数数据*/
       		   		ioctl(vd->fd, VIDIOC_QUERYCAP, &vd->cap);
       		   		/*根据用户指定参数设置设备*/
       		   		ioctl(vd->fd, VIDIOC_S_FMT, &vd->fmt)
       		   		mmap(0 /* start anywhere */ ,
                      vd->buf.length, PROT_READ, MAP_SHARED, vd->fd,
                      vd->buf.m.offset);
       		   }
       		}	
       }
       input_run（）
       {
       		pglobal->buf = malloc(videoIn->framesizeIn);
       		pthread_create(&cam, 0, cam_thread, NULL);
       }
       cam_thread（）
       {
       	  /*抓取一张图片数据*/
       		uvcGrab(videoIn)
       		{
       			video_enable(vd)
       			{
       					/*启动摄像头*/
       					ioctl(vd->fd, VIDIOC_STREAMON, &type);
       			}
       			/*取图像帧数据*/
       			ioctl(vd->fd, VIDIOC_DQBUF, &vd->buf);
       		}
       		/*拷贝图像帧到pglobal->buf*/
       		pglobal->size = memcpy_picture(pglobal->buf, videoIn->tmpbuffer, videoIn->buf.bytesused);
       }
   结论：input_uvc.so将从摄像头获取到的图像帧保存到了pglobal->buf
   2.3  plugins/output_http/
      output_init（）
      {
      	port = htons(8080);
      	/*参数解析*/
      }
      output_run()
      {
      	pthread_create(&(servers[id].threadID), NULL, server_thread, &(servers[id]));
      }
      server_thread()
      {
      	socket(PF_INET, SOCK_STREAM, 0)
      	bind(pcontext->sd, (struct sockaddr*)&addr, sizeof(addr))
      	listen(pcontext->sd, 10)
      	accept(pcontext->sd, (struct sockaddr *)&client_addr, &addr_len);
      	pthread_create(&client, NULL, &client_thread, pcfd)
      }
      
      client_thread()
      {
      	/*接收客户端的输入*/
      	_readline()
      	{
      		_read(fd, iobuf, &c, 1, timeout)
      		{
      			read(fd, &iobuf->buffer, IO_BUFFER))
      		}
      	}
      	/*判断客户端的请求类型*/
      	 else if ( strstr(buffer, "GET /?action=stream") != NULL ) {
				    req.type = A_STREAM;
				  }
				 。。。
				 case A_STREAM:
				    send_stream(lcfd.fd)
				    {
				    	sprintf(buffer, "HTTP/1.0 200 OK\r\n" \
                  STD_HEADER \
                  "Content-Type: multipart/x-mixed-replace;boundary=" BOUNDARY "\r\n" \
                  "\r\n" \
                  "--" BOUNDARY "\r\n");
              /*写buffer数据到客户端*/
              write(fd, buffer, strlen(buffer)
              /*拷贝pglobal->buf中的图像数据*/
              memcpy(frame, pglobal->buf, frame_size);
              
              。。。
              /*发送图像帧到客户端*/
              write(fd, frame, frame_size)
				    }      	
      }
   结论：如果有客户端连接到sever ,并且给sever发送的数据
       中包含如下字符串：
       "GET /?action=stream"
       那么服务器就会不断将图像帧数据以http协议的格式
       发送给客户端
3、视频客户端的编码移植
   小车有线网卡的IP 172.40.4.10
   保证ping 通 
      1)修改虚拟机中的IP地址和小车处于同一网段
      2）用于桥接的网卡（tts）
   3.1完成GUI界面程序，获取视频服务器的图像数据并显示
   	  1）按照UC 编程 socket编程
   	     完成一个简单的tcp 客户端程序 172.40.4.10 80
   	     给服务器端发送“GET /?action=stream HTTP/1.1\r\n\r\n”
   	     接收服务器端的1024个字节数据
   	     socket(...)
   	     connect(...)
   	     write(“GET /?action=stream HTTP/1.1\r\n\r\n”)
   	     read(buf, 1024)
   	     printf(buf)
   	     
   	     e1.c
   	  2) 每次读1024个字节，循环读取1024*1024次
   	     每次读到的数据/tmp/test.jpg
   	     e2.c
      3) 把每次读取到的数据进行过滤，只保留0xff d8
         。。。。ff d9之间的数据，
         如果保留的数据有一个成对的ff d8 ... ff d9
         将该数据写入test.jpeg
         e3.c
      4) 把3)得到的每一帧图像数据不在写入test.jpeg文件
         而是qlabel
         注意：接收图像并显示图片应该放入一个子线程完成
         QTcpSocket
             通过该类的connectToHost连接服务器
             write数据发送
             readall接收数据
             SIGNAL: readyread()  --->SLOT:readImage
             
             readImage
                可能会发射信号 newImageReady(QImage img)----》SLOT:showNewImage(QImage img)
        QImage
        QByteArray
code_for_mjpgstreamer.rar
   3.2把该界面程序移植到开发板上运行
      1）让手里的开发板可以ping小车
      2）动态显示图片数据需要使用QT的插件库
         将plugins/imageformats插件库部署到开发板
           a)cp 插件库到开发板
           b)export QT_PLUGIN_PATH=$QTDIR/plugins
4.WIFI模块
  4.1wifi驱动程序
     http://www.realtek.com.tw
     rtl8111eu_USB_linux.tar.gz
     cd tcar
     mkdir wifi
     cd wifi
     cp /mnt/hgfs/project/tool/rtl8188eu_USB_linux.tar.gz ./
     tar xf rtl8188eu_USB_linux.tar.gz
     cd 8188eu_USB_linux/driver/rtl8188eu
     要想编译该目录下的驱动程序，入手点：
         README
         Makefile
     vi Makefile
         修改 CONFIG_PLATFORM_I386_PC = n
         增加 CONFIG_PLATFORM_ARM_S5PV210 = y
         增加
         ifeq ($(CONFIG_PLATFORM_ARM_S5PV210), y)
						EXTRA_CFLAGS += -DCONFIG_LITTLE_ENDIAN
						ARCH := arm 
						CROSS_COMPILE := arm-linux-
						KVER  := 2.6.35.7
						KSRC ?= /home/tarena/kernel/
				 endif
		  make
		  cp 8188eu.ko /home/tarena/tcar/rootfs/home/modules/
		  在开发板上执行
		     插入wifi模块
		     insmod 8188eu.ko
		     cat /proc/net/wireless
		        wlan0:
	4.2应用程序
	   4.2.1hostapd
	      开源程序，能够使无线网卡切换为master模式
	      来模拟AP（路由器）功能
	      AP ： access point
	     wpa_supplicant_hostapd-0.8_rtw_20120803.zip
	     cd /home/tarena/tcar/wifi/8188eu_USB_linux/wpa_supplicant_hostapd
	     unzip wpa_supplicant_hostapd-0.8_rtw_20120803.zip
	     cd wpa_supplicant_hostapd-0.8/hostapd
	     如何编译ARM版本的hostapd可执行程序 
	        1）README
	        2) Makefile
	     vi Makefile
	       增加CC=arm-linux-gcc
       make
       cp hostapd /home/tarena/tcar/rootfs/home/bin/
       vi rtl_hostapd_2G.conf
                 interface=wlan0   #接入点设备名称
					       ssid=rtwap #无线接入点的名称
					       auth_algs   #认证算法
					       wpa=2       #加密方式WPA/WPA2
						     wpa_passphrase=87654321 #加密密钥
		   cp /mnt/hgfs/project/tool/wifi/rtl_hostapd_2G.conf  /home/tarena/tcar/rootfs/home/etc/
		   在开发板上执行
		       插入wifi
		       insmod 8188eu.ko
		       ifconfig wlan0 192.168.137.1
		       ifconfig 观察开发板上已有的网络设备
		       /home/bin/hostapd  /home/etc/rtl_hostapd_2G.conf -B
		 4.2.2动态分配IP地址
		     dnsmasq-2.66.tar.gz,实现了两个功能：动态分配IP 
		                                         域名解析:dns
		     cp /mnt/hgfs/project/tool/dnsmasq-2.66.tar.gz ./
		     tar xf dnsmasq-2.66.tar.gz
		     cd dnsmasq-2.66/
		     vi Makefile
		        CC=arm-linux-gcc
		     make
		     cp src/dnsmasq /home/tarena/tcar/rootfs/home/bin/
		     关于dnsmasq.conf的配置
		        interface=wlan0   #接入点设备名称
			      domain=tcar.com #域设置
			      dhcp-range=192.168.137.1,192.168.137.150
         cp /mnt/hgfs/project/tool/wifi/dnsmasq.conf /home/tarena/tcar/rootfs/home/etc/
         在开发板上执行
           插入wifi
		       insmod 8188eu.ko
		       ifconfig wlan0 192.168.137.1
		       ifconfig 观察开发板上已有的网络设备
		       /home/bin/hostapd  /home/etc/rtl_hostapd_2G.conf -B
           mkdir /var/lib/misc/ -p
           export LD_LIBRARY_PATH=/home/lib
           /home/bin/dnsmasq -C /home/etc/dnsmasq.conf
           注意：dnsmasq运行时，需要确保存在/etc/passwd
      4.2.3wifi当做客户端连接到路由器
         wpa_supplicant工具软件，配置无线网络。 
         
         
         1）编译生成 wpa_supplicant工具
            /home/tarena/tcar/wifi/8188eu_USB_linux/wpa_supplicant_hostapd/wpa_supplicant_hostapd-0.8/wpa_supplicant
            vi Makefile
              CC=arm-linux-gcc
         2）cp wpa_supplicant /home/tarena/tcar/rootfs/home/bin/
            cp wpa_cli /home/tarena/tcar/rootfs/home/bin/
            cp wpa_passphrase /home/tarena/tcar/rootfs/home/bin/
        	
         3）准备可以联网的路由器(开启手机上的热点)
            
            TEST
            12345678
         4) 操作步骤
            a) insmod 8188eu.ko
            b) ifconfig wlan0
               
            c) ./wpa_passphrase TEST 12345678 >/home/etc/wpa.conf
                生成如下内容
                 network={
									        ssid="TEST"
									        #psk="12345678"
									        psk=0a53ac7fc02148bc90ffba0179794b45476a7e469b6b2ea2780cf4f361771d80
									}
					   
					    
					    //连接热点
					   d)export LD_LIBRARY_PATH=/home/lib 
					     ./wpa_supplicant -Dwext -iwlan0 -c /home/etc/wpa.conf -dd & 
					    
					    
					   e)自动获取IP地址
					      mkdir /home/tarena/tcar/rootfs/usr/share/udhcpc -p
					      cp busybox-1.19.4/examples/udhcp/simple.script /home/tarena/car/rootfs/usr/share/udhcpc/default.script
					      
					   		udhcpc -i wlan0//若没有该命令需要用busybox生成
					   		
					   		以上的命令完成的功能：
					   		    动态获取到IP地址
					   		    自动生成了resolv.conf，指明了DNS服务器
					   		    添加了网关
					   		验证：
					   		    ifconfig waln0查看ip等信息
					   		    如果wlan0的IP为192.168.43.254
					   		    则可以ping 一下手机
					   		    ping 192.168.43.1
					   		    如果手机可以上网可以尝试ping 外网 如百度:119.75.218.70
					   		    ping 119.75.218.70 废手机流量的，节省使用
					   		    ping www.baidu.com//如果不通参照4.2.4
					   		 
					   		或者可以手动完成IP地址配置
					   		    ifconfig wlan0 192.168.43.55
					   		    route add default gw 192.168.43.1
					   		    添加/etc/resolv.conf
					   		       nameserver 192.168.43.1
					   		
				4.2.4如何使开发板能通过域名直接ping通外网
				     ping www.sohu.com
				     1) /etc/resolv.conf 指明了DNS服务器
				     		nameserver 192.168.43.1  这是热点的IP
				     		
				     		该文件是自动由dhcpc程序自动生成的
				     2）动态库
				        libresolv.so
static: 修饰函数 全局变量 局部变量
const
volatile: 防止的编译的优化
     GPC1_DAT 
     #define GPC1_DAT     *((unsigned int *)0xffff8980)
     int a = GPC1_DAT
         ldr r0, =0xffff8980
         ldr r1, [r0]
         ldr r2,  &a
         str r1, [r2]         
     int b = GPC1_DAT
         ldr r2, &b
         str r1, [r2]
     1)访问硬件寄存器
     2）中断程序和进程共享的全局变量
        int a = g_test;
        ...
        int b = g_test;
     3) 线程和线程间共享的全局变量
     在项目开发中尽量不要使用全局变量
可重入函数：
    判断一个函数是否具有可重入性是否使用了全局变量
回调函数：
    总线的匹配函数
    舵机驱动 应用开发
    电机驱动 应用开发
  智能家居项目重点体会嵌入式软件的开发流程
  嵌入式笔试16道经典题
  林锐 高质量的C/C++编程

tool/tcar_sever_code.zip
tool/tcar_client_code.tar.gz 
5、电机模块
   L298N芯片：L298N电机驱动器使用说明书、
   ENABLEA: S5PV210_GPH3(2)
   TCAR_IN1: S5PV210_GPH2(2)
   如果确定了ENABLEA ENABLEB INPUT1~3使用的GPIO管脚
   5.1编写电机的驱动程序
      在tcar_drv.c中找到ENABLEA ... INPUT1~3对应的管脚信息
      自己编写电机驱动程序
   5.2写一个UDP的客户端程序 命令行
      向小车服务器发送30,31,32,33实现小车的运动控制
   5.3完成一个带GUI界面的客户端程序
      用户点击向左的箭头按钮实现左转
      。。。。
      tool/tcar_client_code.tar.gz 
   
       
       
	       
           
         
   
      
    
    
    
    

          